"use strict";(self.webpackChunkioc_workshop=self.webpackChunkioc_workshop||[]).push([[328],{44:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return h}});var o=t(7462),r=t(3366),a=(t(7294),t(3905)),i=["components"],s={title:"2. Architect controllers",sidebar_position:2},l=void 0,c={unversionedId:"chapters/controllers",id:"chapters/controllers",isDocsHomePage:!1,title:"2. Architect controllers",description:"I choose a lazy person to do a hard job.",source:"@site/docs/chapters/2. controllers.md",sourceDirName:"chapters",slug:"/chapters/controllers",permalink:"/ioc-workshop/docs/chapters/controllers",editUrl:"https://github.com/trunkrs/ioc-workshop/docs/chapters/2. controllers.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"2. Architect controllers",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"1. Define the process",permalink:"/ioc-workshop/docs/chapters/process"},next:{title:"3. Retrospect our work",permalink:"/ioc-workshop/docs/chapters/summary"}},u=[{value:"The controller",id:"the-controller",children:[]}],d={toc:u};function h(e){var n=e.components,t=(0,r.Z)(e,i);return(0,a.kt)("wrapper",(0,o.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"I choose a lazy person to do a hard job.\nBecause a lazy person will find an easy way to do it."),(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("em",{parentName:"p"},"- Bill Gates"))),(0,a.kt)("p",null,"Now let\u2019s start with designing our architecture. As developers, we are lazy and should shy away from actually writing code. So we\u2019re going to start at the top and work our way down the chain to make the most efficient progress in writing code. As we will only write what we need when we actually need it."),(0,a.kt)("p",null,"With this methodology in mind, let\u2019s start at the outer bounds and work our way to the core of our application. In the previous part, we defined that the process starts with user interaction."),(0,a.kt)("h3",{id:"the-controller"},"The controller"),(0,a.kt)("p",null,"Any entry point of our application will lead to a controller. Controllers are classes that host actions that can be called by an external actor. The responsibility of these actions is to assess the validity of the input and the delegation to a manager class that hosts the business logic for the action."),(0,a.kt)("p",null,"Let\u2019s start by defining the actions an external actor can do with our vending machine:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"class VendingMachineController {\n  public selectAndBuyDrink(\n    // The external actor supplies us only a number of the button clicked.\n    drink: number,\n  ): Promise<void> {\n    // TODO: Define action body\n  }\n}\n")),(0,a.kt)("p",null,"We only have a single action on our controller. Even though it would be imaginable that the user would be able to cancel their transaction mid-selection, we didn\u2019t define it as part of our process and thus it isn\u2019t part of our implementation."),(0,a.kt)("p",null,"Now that we have defined our actions, we should start by writing down our expectations for our controller. These expectations come from our process definition and our business logic/constraints. By pre-defining these in tests, we will write our code in the most efficient way possible."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"describe('VendingMachineController', () => {\n  let sut: VendingMachineController\n  \n  beforeEach(() => {\n    sut = new VendingMachineController()\n  })\n\n  describe('selectAndBuyDrink', () => {\n    it('should delegate the right drink type to the manager', () => {\n      // TODO: Test for our expectations\n    })\n  })\n})\n")),(0,a.kt)("p",null,"Now, to test our expectations we will need to stub the manager with the method we\u2019re going to call. The manager has the responsibility of guarding the business rules and delegating to underlying repositories and services. Business rules should never be implemented outside of our business layer where the managers reside."),(0,a.kt)("p",null,"We don\u2019t want to implement the manager yet because we\u2019re still focusing on our controller. Let\u2019s implement our stubbed manager."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"class VendingMachineManager {\n  /**\n  * Executes a transaction to buy and dispense a drink.\n  * @param drinkNr The drink button number to dispense.\n  */\n  public buyDrink(drinkNr: number): Promise<void> {\n    // TODO: Implement logic\n  }\n}\n")),(0,a.kt)("p",null,"Now that we have clearly defined our manager, we can add the manager as one of our controllers' dependencies. Some unchanged lines have been omitted for brevity."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"class VendingMachineController {\n  public constructor(\n    private readonly manager: VendingMachineManager,\n  ) {}\n  \n  [...]\n}\n")),(0,a.kt)("p",null,"Let\u2019s now implement our expectations fully while mocking the manager so that we can run the tests in a truly isolated fashion."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"const createMockedManager = () => ({\n  buyDrink: jest.fn().mockResolvesValue(undefined)\n})\n\ndescribe('VendingMachineController', () => {\n  let mockedManager = createMockedManager()\n  let sut: VendingMachineController\n  \n  beforeEach(() => {\n    mockedManager = createMockedManager()\n    sut = new VendingMachineController(\n      mockedManager as unknown as VendingMachineManager,\n    )\n  })\n\n  describe('selectAndBuyDrink', () => {\n    it('should delegate the right drink type to the manager', async () => {\n      const buttonNumber = 6\n      \n      await sut.selectAndBuyDrink(buttonNumber)\n      \n      expect(mockedManager.buyDrink).toBeCalledWith(buttonNumber)\n    })\n  })\n})\n")),(0,a.kt)("p",null,"Now that we have written out our expectations, we can go ahead with implementing the controller itself. Some lines have been omitted for the sake of brevity."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"class VendingMachineController {\n  [...]\n \n  public async selectAndBuyDrink(\n    // The external actor supplies us only a number of the button clicked.\n    drink: number,\n  ): Promise<void> {\n    await this.manager.buyDrink(drink)\n  }\n}\n")),(0,a.kt)("p",null,"And we are done! We have written a controller and established the basic outline, also called stubbing, of our manager that will handle the business rules of our vending machine."))}h.isMDXComponent=!0}}]);