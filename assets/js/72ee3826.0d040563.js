"use strict";(self.webpackChunkioc_workshop=self.webpackChunkioc_workshop||[]).push([[251],{1007:function(e,t,o){o.r(t),o.d(t,{frontMatter:function(){return a},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return d},default:function(){return p}});var n=o(7462),i=o(3366),r=(o(7294),o(3905)),s=["components"],a={title:"3. Retrospect our work",sidebar_position:2},l=void 0,c={unversionedId:"chapters/summary",id:"chapters/summary",isDocsHomePage:!1,title:"3. Retrospect our work",description:"Now that we've implemented our first part of the application.",source:"@site/docs/chapters/3. summary.md",sourceDirName:"chapters",slug:"/chapters/summary",permalink:"/ioc-workshop/docs/chapters/summary",editUrl:"https://github.com/trunkrs/ioc-workshop/docs/chapters/3. summary.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"3. Retrospect our work",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"2. Architect controllers",permalink:"/ioc-workshop/docs/chapters/controllers"},next:{title:"4. Implement business rules",permalink:"/ioc-workshop/docs/chapters/managers"}},d=[{value:"Dependency injection",id:"dependency-injection",children:[]},{value:"Layered responsibility",id:"layered-responsibility",children:[]},{value:"Test-driven development",id:"test-driven-development",children:[]}],u={toc:d};function p(e){var t=e.components,o=(0,i.Z)(e,s);return(0,r.kt)("wrapper",(0,n.Z)({},u,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Now that we've implemented our first part of the application.\nLet's look back for a moment and see what we have done and why we have done it."),(0,r.kt)("h3",{id:"dependency-injection"},"Dependency injection"),(0,r.kt)("p",null,"This is our first approach to developing code in the world of dependency injection.\nWe have isolated the dependencies of our code and made sure, beyond the public interface, our code doesn\u2019t need to know what its dependencies do or how they are implemented.\nNext to decoupling our code from dependencies, it makes testing truly heavenly.\nYou will only have to look at the constructor of your subject under test to see what you need to mock to make it all work."),(0,r.kt)("h3",{id:"layered-responsibility"},"Layered responsibility"),(0,r.kt)("p",null,"We have established the first layer of our application.\nIn this instance, it seems very useless to decouple the external button click from the business layer.\nBut we don\u2019t know what kind of magical interfaces the future will hold.\nOur control layer(the controller) will let us implement completely different interfaces without having to change a single line of code concerning the business side of our vending machine.\nAnother benefit of this layered approach is that it sets a very clear boundary for the responsibility of your code."),(0,r.kt)("h3",{id:"test-driven-development"},"Test-driven development"),(0,r.kt)("p",null,"The last important methodology we used is called test-driven development.\nThe idea is that you write out all your expectations of your code in tests.\nOnly then you are going to write your actual code.\nBecause all your expectations stroke with the business values, or at least they should \ud83d\ude09, you\u2019re never writing one more line than is necessary.\nNext to the business value, you also spend less time on writing your code and write fewer mistakes because all of your code is always completely tested."))}p.isMDXComponent=!0}}]);