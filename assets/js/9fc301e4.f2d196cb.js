"use strict";(self.webpackChunkioc_workshop=self.webpackChunkioc_workshop||[]).push([[298],{8100:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return o},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return d},default:function(){return h}});var i=t(7462),a=t(3366),s=(t(7294),t(3905)),r=["components"],o={title:"4. Implement business rules",sidebar_position:4},c=void 0,l={unversionedId:"chapters/managers",id:"chapters/managers",isDocsHomePage:!1,title:"4. Implement business rules",description:"In the first chapter, we\u2019ve looked at the processes and defined our business rules.",source:"@site/docs/chapters/4. managers.md",sourceDirName:"chapters",slug:"/chapters/managers",permalink:"/ioc-workshop/docs/chapters/managers",editUrl:"https://github.com/trunkrs/ioc-workshop/docs/chapters/4. managers.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"4. Implement business rules",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"3. Retrospect our work",permalink:"/ioc-workshop/docs/chapters/summary"}},d=[{value:"The manager",id:"the-manager",children:[]}],p={toc:d};function h(e){var n=e.components,t=(0,a.Z)(e,r);return(0,s.kt)("wrapper",(0,i.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"In the first chapter, we\u2019ve looked at the processes and defined our business rules.\nIn this chapter, we\u2019re going to use those definitions to set up our business layer.\nThis layer consists of managers that implement the business rules and constraints.\nIt will contain most of the important decisions in our code.\nIt also delegates commands to repositories and clients on the data and service layers."),(0,s.kt)("h3",{id:"the-manager"},"The manager"),(0,s.kt)("p",null,"Let\u2019s look again at the business rules we\u2019ve defined in our first chapter. They are:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"When the customer selects a drink and the drink is available then show the price otherwise ask the customer to select another drink"),(0,s.kt)("li",{parentName:"ul"},"When the customer selects a drink and the drink is available then activate the payment terminal"),(0,s.kt)("li",{parentName:"ul"},"When the bank has approved the transaction then dispense the drink"),(0,s.kt)("li",{parentName:"ul"},"When the bank rejects the transaction then go back into the initial state")),(0,s.kt)("p",null,"We\u2019ve already defined the outline of the manager class in the last chapter. So let\u2019s now go ahead with defining our expectations for our manager by setting up the test scenarios."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"describe('VendingMachineManager', () => {\n  let sut: VendingMachineManager\n\n  beforeEach(() => {\n    sut = new VendingMachineManager()\n  })\n  \n  describe('buyDrink', () => {\n    it('should retrieve the drink details', () => {\n      // TODO: Implement scenario\n    })\n    \n    it('should reset transaction when drink not available', () => {\n      // TODO: Implement scenario\n    })\n    \n    it('should start a payment transaction when selected drink available', () => {\n      // TODO: Implement scenario\n    })\n    \n    it('should dispense the drink when the payment is successful', () => {\n      // TODO: Implement scenario\n    })\n    \n    it('should log the dispensed drink as to be to recognize availability', () => {\n      // TODO: Implement scenario\n    })\n    \n    it('should reset transaction when the payment is rejected', () => {\n      // TODO: Implement scenario\n    })\n  })\n})\n")),(0,s.kt)("p",null,"The next step is defining the dependencies of our manager. From our expectations we can see three clear dependencies:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("inlineCode",{parentName:"li"},"DrinkRepository"),": The repository that interacts with the internal data storage of the vending machine."),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("inlineCode",{parentName:"li"},"MechatronicsClient"),": The pre-defined client that interacts with the mechatronics of the machine. Think dispense a drink or reset the interface."),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("inlineCode",{parentName:"li"},"PaymentClient"),": The pre-defined bank transaction client.")),(0,s.kt)("p",null,"The workshop project has some pre-defined classes.\nThese have been added to make you focus on the core values of the workshop and not having to focus on any of the parts that are not relevant."),(0,s.kt)("p",null,"The only dependency we have to define ourselves is the repository and connect it to the internal data store.\nLet\u2019s create a stub with the appropriate models so that our manager can interact with the data store."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"interface DrinkEntity {\n  ean13: string\n  name: string\n  pos: number\n  price: number\n  qtyAvailable: number\n}\n\ninterface Drink {\n  position: number\n  name: string\n  price: number\n  isAvailable: boolean\n}\n\nclass DrinkRepository {\n  public constructor(\n    private readonly datastorage: DataStorage<DrinkEntity>,\n  ) {}\n\n  /**\n   * Retrieves the corresponding drink by its position\n   * @param position The drink position\n   */\n  public getDrink(position: number): Promise<Drink> {\n    // TODO: Implement method\n  }\n  \n  /**\n   * Logs that a drink has been dispensed by the machine.\n   * @param position The drink position\n   */\n  public logDrinkDispensed(position: number): Promise<void> {\n    // TODO: Implement method\n  }\n}\n")),(0,s.kt)("p",null,"Now that we have architected our dependencies, we\u2019re ready to implement the test scenarios to check whether our expectations for the manager are being met."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"const createMockedRepository = () => ({\n  getDrink: jest.fn().mockResolvedValue(undefined),\n  logDrinkDispensed: jest.fn().mockResolvedValue(undefined),\n})\n\nconst createMockedMechaClient = () => ({\n  resetTransaction: jest.fn().mockResolvedValue(undefined),\n  dispense: jest.fn().mockResolvedValue(undefined),\n})\n\nconst createMockedPaymentClient = () => ({\n doPayment: jest.fn().mockResolvedValue(PaymentResult.Success),\n})\n\nconst createDrink = (\n  isAvailable = true,\n  position = 5,\n  price = 250\n): Drink => ({\n  position,\n  name: 'Regular Coca-Cola',\n  price,\n  isAvailable,\n}) \n\ndescribe('VendingMachineManager', () => {\n  let mockedRepo = createMockedRepository()\n  let mockedMechaClient = createMockedMechaClient()\n  let mockedPaymentClient = createMockedPaymentClient()\n\n  let sut: VendingMachineManager\n\n  beforeEach(() => {\n    let mockedRepo = createMockedRepository()\n    let mockedMechaClient = createMockedMechaClient()\n    let mockedPaymentClient = createMockedPaymentClient()\n  \n    sut = new VendingMachineManager(\n      mockedRepo as unknown as DrinkRepository,\n      mockedMechaClient as unknown as MechatronicsClient,\n      mockedPaymentClient as unknown as PaymentClient,\n    )\n  })\n  \n  describe('buyDrink', () => {\n    it('should retrieve the drink details', async () => {\n      const drinkPosition = 5\n      mockedRepo\n        .getDrink\n        .mockResolvedValueOnce(createDrink(true, drinkPosition))\n    \n      await sut.buyDrink(drinkPosition)\n      \n      expect(mockedRepo.getDrink).toHaveBeenCalledWith(drinkPosition)\n    })\n    \n    it('should reset transaction when drink not available', async () => {\n      const drinkPosition = 5\n      mockedRepo\n        .getDrink\n        .mockResolvedValueOnce(createDrink(false, drinkPosition))\n      \n      await sut.buyDrink(drinkPosition)\n      \n      expect(mockedMechaClient.resetTransaction).toHaveBeenCalled()\n    })\n    \n    it('should start a payment transaction when selected drink available', async () => {\n      const drinkPosition = 5\n      const drinkPrice = 375\n      mockedRepo\n        .getDrink\n        .mockResolvedValueOnce(createDrink(true, drinkPosition, drinkPrice))\n        \n      await sut.buyDrink(drinkPosition)\n      \n      expect(mockedPaymentClient.doPayment).toHaveBeenCalledWith(drinkPrice)\n    })\n    \n    it('should dispense the drink when the payment is successful', async () => {\n      const drinkPosition = 5\n      mockedRepo\n        .getDrink\n        .mockResolvedValueOnce(createDrink(true, drinkPosition))\n        \n        await sut.buyDrink(drinkPosition)\n        \n        expect(mockedMechaClient.dispense).toHaveBeenCalledWith(drinkPosition)\n    })\n    \n    it('should reset transaction when the payment is rejected', async () => {\n      mockedPaymentClient\n        .doPayment\n        .mockResolvedValueOnce(PaymentResult.Fail)\n      mockedRepo\n        .getDrink\n        .mockResolvedValueOnce(createDrink())\n        \n        await sut.buyDrink(5)\n        \n        expect(mockedMechaClient.resetTransaction).toHaveBeenCalled()\n    })\n    \n    it('should log the dispensed drink as to be to recognize availability', async () => {\n      const drinkPosition = 5\n      mockedRepo\n        .getDrink\n        .mockResolvedValueOnce(createDrink(true, drinkPosition))\n        \n      await sut.buyDrink(drinkPosition)\n      \n      expect(mockedRepo.logDrinkDispensed).toHaveBeenCalled()\n    })\n  })\n})\n")),(0,s.kt)("p",null,"Hell yeah! These are our tests that define our business rules perfectly for the vending machine. Let\u2019s now go ahead and implement our manager. This part is going to be easy!"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript"},"class VendingMachineManager {\n  public constructor(\n    private readonly repo: DrinkRepository,\n    private readonly mechaClient: MechatronicsClient,\n    private readonly paymentClient: PaymentClient,\n  ) {}\n\n  /**\n   * Executes a transaction to buy and dispense a drink.\n   * @param drinkNr The drink button number to dispense.\n   */\n  public async buyDrink(drinkNr: number): Promise<void> {\n    const drink = await this.repo.getDrink(drinkNr)\n    if (!drink.isAvailable) {\n      await this.mechaClient.resetTransaction()\n      return\n    }\n    \n    const paymentResult = await this.paymentClient.doPayment(drink.price)\n    if (paymentResult === PaymentResult.Success) {\n      await this.mechaClient.dispense(drinkNr)\n    } else {\n      await this.mechaClient.resetTransaction()\n    }\n  }\n}\n")),(0,s.kt)("p",null,"Bam that\u2019s it!  Easy peasy lemon squezie! \ud83c\udf4b\ud83c\udf4b\ud83c\udf4b"))}h.isMDXComponent=!0}}]);